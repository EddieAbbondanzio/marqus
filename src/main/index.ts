import {
  app,
  BrowserWindow,
  HeadersReceivedResponse,
  ipcMain,
  OnHeadersReceivedListenerDetails,
  session,
} from "electron";
import { getProcessType, isDevelopment, isTest } from "../shared/env";
import { IpcMainTS } from "../shared/ipc";
import { appIpcs } from "./ipcs/app";
import { configIpcs, getConfig } from "./ipcs/config";
import { noteIpcs } from "./ipcs/notes";

import { shortcutIpcs } from "./ipcs/shortcuts";
import { getLogger, logIpcs } from "./ipcs/log";
import { Protocol } from "../shared/domain/protocols";
import { JsonFile } from "./json";
import { Config } from "../shared/domain/config";
import { Logger } from "../shared/logger";

export interface AppContext {
  browserWindow: BrowserWindow;
  ipc: IpcMainTS;
  config: JsonFile<Config>;
  log: Logger;
  blockAppFromQuitting: (cb: () => Promise<void>) => Promise<void>;
}

if (!isTest() && getProcessType() !== "main") {
  throw Error(
    "ipcMain is null. Did you accidentally import main.ts in the renderer thread?",
  );
}

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let mainWindow: BrowserWindow;

export async function main(): Promise<void> {
  try {
    const configFile = await getConfig();
    const log = await getLogger(configFile, console);

    // Handle creating/removing shortcuts on Windows when installing/uninstalling.
    if (require("electron-squirrel-startup")) {
      app.quit();
    }

    // Quit when all windows are closed, except on macOS. There, it's common
    // for applications and their menu bar to stay active until the user quits
    // explicitly with Cmd + Q.
    app.on("window-all-closed", () => {
      if (process.platform !== "darwin") {
        app.quit();
      }
    });

    app.on("activate", async () => {
      // On OS X it's common to re-create a window in the app when the
      // dock icon is clicked and there are no other windows open.
      if (BrowserWindow.getAllWindows().length === 0) {
        await createWindow();
      }
    });

    // If the app is closed while writing to the file system, we risk corrupting
    // a file so we block it from "closing" by keeping it running in the background
    // until we can finish whatever we were doing.
    let keepAlivePromise: Promise<unknown> | undefined;
    const blockAppFromQuitting = async (
      cb: () => Promise<void>,
    ): Promise<void> => {
      keepAlivePromise = cb();
      await keepAlivePromise;
      keepAlivePromise = undefined;
    };

    let quitInitiated = false;
    app.on("before-quit", async ev => {
      if (keepAlivePromise) {
        ev.preventDefault();

        await keepAlivePromise;
        app.quit();

        return;
      }

      if (!quitInitiated) {
        // Post-pone quitting so we can save off the log file first.
        ev.preventDefault();
        await log.close();

        // Use console.log() over log.info to avoid appending this to the log file
        // eslint-disable-next-line no-console
        console.log(`Shutting down. Log saved to: ${log.filePath}`);

        // Now let the app close.
        quitInitiated = true;
        app.quit();
      }
    });

    const createWindow = async (): Promise<void> => {
      // Only allow external images
      session.defaultSession.webRequest.onHeadersReceived(setCspHeader);

      const { windowHeight, windowWidth, autoHideAppMenu } = configFile.content;

      mainWindow = new BrowserWindow({
        // Title must be specified otherwise npm package name will be used until
        // index.html has loaded.
        title: "Marker",
        icon: "static/icon.png",
        height: windowHeight,
        width: windowWidth,
        autoHideMenuBar: autoHideAppMenu,
        webPreferences: {
          preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
          // Do not change these. They are for security purposes.
          nodeIntegration: false,
          contextIsolation: true,
        },
      });

      // Setup ipc modules
      const typeSafeIpc = ipcMain as IpcMainTS;
      const appContext = {
        ipc: typeSafeIpc,
        browserWindow: mainWindow,
        log,
        config: configFile,
        blockAppFromQuitting,
      };

      logIpcs(appContext);
      configIpcs(appContext);
      appIpcs(appContext);
      shortcutIpcs(appContext);
      noteIpcs(appContext);

      await initPlugins(typeSafeIpc);

      // and load the index.html of the app.
      await mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

      if (isDevelopment()) {
        mainWindow.webContents.openDevTools();
      }
    };

    // Ready event might fire before we finish loading our config file causing us
    // to miss it.
    // Source: https://github.com/electron/electron/issues/12557
    if (app.isReady()) {
      await createWindow();
    } else {
      app.on("ready", createWindow);
    }
  } catch (err) {
    console.error("Error: Failed to initialize app.");
    console.error(err);
  }
}

// We don't want to run the app while testing.
if (!isTest()) {
  void main();
}

export async function initPlugins(typeSafeIpc: IpcMainTS): Promise<unknown> {
  const initListeners = typeSafeIpc.listeners("init");
  return await Promise.all(initListeners.map(l => l()));
}

export function setCspHeader(
  details: OnHeadersReceivedListenerDetails,
  callback: (headersReceivedResponse: HeadersReceivedResponse) => void,
): void {
  callback({
    responseHeaders: Object.assign(
      {
        ...details.responseHeaders,
        // Should be kept in sync with content security policy in forge.config.js
        "Content-Security-Policy": [`img-src * ${Protocol.Attachment}://*`],
      },
      details.responseHeaders,
    ),
  });
}
